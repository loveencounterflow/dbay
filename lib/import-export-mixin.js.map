{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/import-export-mixin.coffee"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "\n\n'use strict'\n\n############################################################################################################\nCND                       = require 'cnd'\nrpr                       = CND.rpr\nbadge                     = 'ICQL-DBA/IMPORT-EXPORT-MIXIN'\ndebug                     = CND.get_logger 'debug',     badge\nwarn                      = CND.get_logger 'warn',      badge\ninfo                      = CND.get_logger 'info',      badge\nurge                      = CND.get_logger 'urge',      badge\nhelp                      = CND.get_logger 'help',      badge\nwhisper                   = CND.get_logger 'whisper',   badge\necho                      = CND.echo.bind CND\n#...........................................................................................................\nPATH                      = require 'path'\nFS                        = require 'fs'\nE                         = require './errors'\n{ misfit }                = require './common'\n\n# #-----------------------------------------------------------------------------------------------------------\n# any_value_null = ( input_columns, object ) ->\n#   for k in input_columns\n#     return true unless object[ k ]?\n#   return false\n\n# #-----------------------------------------------------------------------------------------------------------\n# all_values_null = ( input_columns, object ) ->\n#   for k in input_columns\n#     return false if object[ k ]?\n#   return true\n\n\n#-----------------------------------------------------------------------------------------------------------\n@Import_export_mixin = ( clasz = Object ) => class extends clasz\n\n  #---------------------------------------------------------------------------------------------------------\n  import: ( cfg ) ->\n    cfg         = { @types.defaults.dba_import_cfg..., cfg..., }\n    cfg.format ?= @_format_from_path cfg.path\n    @types.validate.dba_import_cfg cfg\n    switch cfg.format\n      # when 'db'   then await @_import_db  cfg\n      # when 'sql'  then await @_import_sql cfg\n      when 'csv', 'tsv' then await @_import_csv_tsv cfg\n      else\n        if @types._import_formats.has cfg.format\n          throw new E.Dba_not_implemented '^dba@309^', \"import format #{rpr cfg.format}\"\n        throw new E.Dba_import_format_unknown '^dba@309^', cfg.format\n    return null\n\n\n  #=========================================================================================================\n  # FORMAT GUESSING\n  #---------------------------------------------------------------------------------------------------------\n  _extension_from_path: ( path ) -> if ( R = PATH.extname path ) is '' then null else R[ 1 .. ]\n  _format_from_path:    ( path ) -> @_formats[ @._extension_from_path path ] ? null\n\n  #---------------------------------------------------------------------------------------------------------\n  _is_sqlite3_db: ( path ) ->\n    # validate.nonempty_text path\n    buffer  = Buffer.alloc 16\n    fd      = FS.openSync path\n    FS.readSync fd, buffer\n    return ( buffer.toString 'utf-8' ) is 'SQLite format 3\\x00'\n\n  #---------------------------------------------------------------------------------------------------------\n  _import_db: ( cfg ) ->\n    tmp_schema = @_get_free_temp_schema()\n    @_attach { schema: tmp_schema, path: cfg.path, }\n    # debug '^469465^', @list_schemas()\n    @_attach { schema: cfg.schema, path: '', }\n    # debug '^469465^', @list_schemas()\n    @copy_schema { from_schema: tmp_schema, to_schema: cfg.schema, }\n    @_detach { schema: tmp_schema, }\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _import_sql: ( cfg ) ->\n    throw new E.Dba_format_unknown '^dba@310^', 'sql'\n\n  #---------------------------------------------------------------------------------------------------------\n  _import_csv_tsv: ( cfg ) -> new Promise ( resolve, reject ) =>\n    ### TAINT always requires `ram: true` ###\n    ### TAINT no streaming, no batching ###\n    ### TAINT no configurable CSV parsing ###\n    ### NOTE optimisation: instead of n-readlines, use (unpublished) `chunkreader` that reads n bytes,\n      only looks for last newline, then parses chunk ###\n    ### NOTE optimisation: do not call `insert` for each line, but assemble big `insert .. values (...)`\n      statement (as done before, should be fastest) ###\n    parse_csv   = require 'csv-parser'\n    cfg         = {\n      @types.defaults.dba_import_cfg...,\n      @types.defaults.dba_import_cfg_csv...,\n      cfg..., }\n    @types.validate.dba_import_cfg_csv cfg\n    { path\n      schema\n      transform\n      input_columns\n      table_columns\n      skip_any_null\n      skip_all_null\n      table_name\n      _extra  } = cfg\n    if cfg.format is 'tsv' then parser_cfg_defaults = @types.defaults.dba_import_cfg_tsv_extra\n    else                        parser_cfg_defaults = @types.defaults.dba_import_cfg_csv_extra\n    parser_cfg  = {\n      parser_cfg_defaults...,\n      _extra...,\n      columns: input_columns, }\n    #.......................................................................................................\n    if      input_columns is false  then parser_cfg.headers = false\n    else if input_columns is true   then delete parser_cfg.headers\n    else parser_cfg.headers = input_columns\n    parser_cfg.skipComments = cfg.skip_comments\n    @types.validate.dba_import_cfg_csv_extra parser_cfg\n    #.......................................................................................................\n    stop        = Symbol.for 'stop'\n    lnr         = 0\n    buffer      = null\n    batch_size  = 1_000\n    @_attach { schema, ram: true, }\n    insert      = null\n    is_first    = true\n    row_count   = 0\n    has_stopped = false\n    source      = null\n    stream      = null\n    #.......................................................................................................\n    flush = =>\n      return null if has_stopped\n      if is_first\n        is_first = false\n        { insert\n          table_columns } = @_create_csv_table { schema, table_name, input_columns, table_columns, }\n        # debug '^324^', input_columns\n        # debug '^324^', table_columns\n      return unless buffer?\n      rows    = buffer\n      buffer  = null\n      #.....................................................................................................\n      for row in rows\n        row_count++\n        unless transform?\n          insert.run ( row[ column ] ? null for column of table_columns )\n          continue\n        #...................................................................................................\n        subrows = await transform { row, stop, }\n        if subrows is stop\n          has_stopped = true\n          source.destroy()\n          stream.destroy()\n          stream.emit 'end'\n          return null\n        continue unless subrows?\n        if @types.isa.list subrows\n          for subrow in subrows\n            insert.run ( subrow[ column ] for column of table_columns )\n          continue\n        insert.run ( subrows[ column ] for column of table_columns )\n      return null\n    # #.......................................................................................................\n    # echo '^3423^'\n    # ### !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ###\n    # t2 = require '../../hengist/node_modules/through2'\n    # ### !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ###\n    # xxx = true\n    # xxx = false\n    # if xxx\n    #   source  = FS.createReadStream path, { highWaterMark: 10, }\n    #   stream  = source.pipe t2 ( chunk, encoding, callback ) ->\n    #     # debug '^333442^', chunk.length\n    #     @push chunk\n    #     callback()\n    #   stream  = stream.pipe parse_csv parser_cfg\n    # else\n    source  = FS.createReadStream path\n    stream  = source.pipe parse_csv parser_cfg\n    #.......................................................................................................\n    stream.on 'data', ( row ) =>\n      return null if has_stopped\n      all_columns_null  = true\n      new_row           = {}\n      #.....................................................................................................\n      for column in input_columns\n        v = row[ column ] ? null\n        v = v.trim() if v? and cfg.trim\n        v = null if v is ''\n        if v is null\n          return null if skip_any_null\n          new_row[ column ] = cfg.default_value\n        else\n          all_columns_null  = false\n          new_row[ column ] = v\n      #.....................................................................................................\n      return null if skip_all_null and all_columns_null\n      ( buffer ?= [] ).push new_row\n      await flush() if buffer.length >= batch_size\n      return null\n    #.......................................................................................................\n    stream.on 'headers', ( headers )  => input_columns = headers\n    stream.on 'end',                  => await flush(); resolve { row_count, }\n    #.......................................................................................................\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _create_csv_table: ( cfg ) ->\n    { schema\n      input_columns\n      table_columns\n      table_name  } = cfg\n    #.......................................................................................................\n    # debug '^3534^', { table_columns, input_columns, }\n    table_columns ?= input_columns\n    if @types.isa.list table_columns then do =>\n      _tc                 = table_columns\n      table_columns       = {}\n      table_columns[ k ]  = 'text' for k in _tc\n    # debug '^3534^', { table_columns, input_columns, }\n    #.......................................................................................................\n    schema_i        = @sql.I schema\n    table_name_i    = @sql.I table_name\n    columns_sql     = ( \"#{@sql.I n} #{@sql.I t}\" for n, t of table_columns ).join ', '\n    placeholder_sql = ( \"?\"                                       for _    of table_columns ).join ', '\n    create_sql      = \"create table #{schema_i}.#{table_name_i} ( #{columns_sql} );\"\n    try @execute create_sql catch error\n      warn CND.reverse \"\"\"when trying to execute SQL:\n\n      #{create_sql}\n\n      an error was encountered: #{error.message}\"\"\"\n      throw error\n    #.......................................................................................................\n    insert = @prepare \"insert into #{schema_i}.#{table_name_i} values ( #{placeholder_sql} );\"\n    return { insert, table_columns, }\n\n  #---------------------------------------------------------------------------------------------------------\n  _import_sql_single: ( cfg ) ->\n    @execute FS.readFileSync cfg.path, { encoding: 'utf-8', }\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _import_sql_batch: ( cfg ) ->\n    for statements from @_walk_batches ( @_walk_statements_from_path cfg.path ), cfg.batch_size\n      compound_statement  = statements.join ''\n      count              += compound_statement.length\n      @execute compound_statement\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_statements_from_path: ( sql_path ) ->\n    ### Given a path, iterate over SQL statements which are signalled by semicolons (`;`) that appear outside\n    of literals and comments (and the end of input). ###\n    ### thx to https://stackabuse.com/reading-a-file-line-by-line-in-node-js/ ###\n    ### thx to https://github.com/nacholibre/node-readlines ###\n    readlines       = new ( require 'n-readlines' ) sql_path\n    #.......................................................................................................\n    cfg           =\n      regExp: ( require 'mysql-tokenizer/lib/regexp-sql92' )\n    tokenize      = ( require 'mysql-tokenizer' ) cfg\n    collector     = null\n    # stream        = FS.createReadStream sql_path\n    #.......................................................................................................\n    flush = ->\n      R         = collector.join ''\n      collector = null\n      return R\n    #.......................................................................................................\n    while ( line = readlines.next() ) isnt false\n      for token, cur_idx in tokenize line + '\\n'\n        if token is ';'\n          ( collector ?= [] ).push token\n          yield flush()\n          continue\n        # if token.startsWith '--'\n        #   continue\n        ( collector ?= [] ).push token\n    #.......................................................................................................\n    yield flush() if collector?\n    return null\n\n  #---------------------------------------------------------------------------------------------------------\n  _walk_batches: ( iterator, batch_size = 1 ) ->\n    ### Given an iterator and a batch size, iterate over lists of values yielded by the iterator. ###\n    batch = null\n    for d from iterator\n      ( batch ?= [] ).push d\n      if batch.length >= batch_size\n        yield batch\n        batch = null\n    yield batch if batch?\n    return null\n"
  ]
}