// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var CND, IC, assign, badge, debug, echo, help, info, inspect, jr, local_methods, rpr, urge, warn, whisper, xrpr;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'ICQL/MAIN';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  // PATH                      = require 'path'
  // PD                        = require 'pipedreams'
  // { $
  //   $async
  //   select }                = PD
  ({assign, jr} = CND);

  // #...........................................................................................................
  // join_path                 = ( P... ) -> PATH.resolve PATH.join P...
  // boolean_as_int            = ( x ) -> if x then 1 else 0
  ({inspect} = require('util'));

  xrpr = function(x) {
    return inspect(x, {
      colors: true,
      breakLength: 2e308,
      maxArrayLength: 2e308,
      depth: 2e308
    });
  };

  //...........................................................................................................
  IC = require('intercourse');

  //===========================================================================================================
  // LOCAL METHODS
  //-----------------------------------------------------------------------------------------------------------
  local_methods = {
    //---------------------------------------------------------------------------------------------------------
    limit: function*(me, n, iterator) {
      var count, x;
      count = 0;
      for (x of iterator) {
        if (count >= n) {
          return;
        }
        count += +1;
        yield x;
      }
    },
    //---------------------------------------------------------------------------------------------------------
    single_row: function(me, iterator) {
      var R;
      if ((R = this.first_row(iterator)) === void 0) {
        throw new Error("µ33833 expected at least one row, got none");
      }
      return R;
    },
    //---------------------------------------------------------------------------------------------------------
    all_first_values: function(me, iterator) {
      var R, key, row, value;
      R = [];
      for (row of iterator) {
        for (key in row) {
          value = row[key];
          R.push(value);
          break;
        }
      }
      return R;
    },
    //---------------------------------------------------------------------------------------------------------
    first_row: function(me, iterator) {
      var row;
      for (row of iterator) {
        return row;
      }
    },
    /* TAINT must ensure order of keys in row is same as order of fields in query */
    single_value: function(me, iterator) {
      var key, ref, value;
      ref = this.single_row(iterator);
      for (key in ref) {
        value = ref[key];
        return value;
      }
    },
    first_value: function(me, iterator) {
      var key, ref, value;
      ref = this.first_row(iterator);
      for (key in ref) {
        value = ref[key];
        return value;
      }
    },
    all_rows: function(me, iterator) {
      return [...iterator];
    },
    //---------------------------------------------------------------------------------------------------------
    load: function(me, path) {
      return me.$.db.loadExtension(path);
    },
    //---------------------------------------------------------------------------------------------------------
    prepare: function(me, sql) {
      info('33983-1', sql);
      return me.$.db.prepare(sql);
    },
    // try
    //   return me.$.db.prepare        sql
    // catch error
    //   debug '33763', ( k for k of error )
    //   throw error
    // return null

    //---------------------------------------------------------------------------------------------------------
    query: function(me, sql, ...P) {
      var statement;
      info('33983-2', sql, P);
      statement = this.prepare(sql);
      return statement.iterate(...P);
    },
    // try
    //   statement = @prepare sql
    // catch error
    //   debug '33983-3', ( k for k of error )
    // try
    //   return statement.iterate P...
    // catch error
    //   debug '33983-4', ( k for k of error )
    //   throw error
    // return null

    //---------------------------------------------------------------------------------------------------------
    execute: function(me, sql) {
      return me.$.db.exec(sql);
    }
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.bind = function(settings) {
    var R, ref;
    if (settings.connector == null) {
      /* TAINT should check connector API compatibility */
      throw new Error("µ94721 need settings.connector");
    }
    if (settings.db_path == null) {
      throw new Error("µ94721 need settings.db_path");
    }
    if (settings.icql_path == null) {
      throw new Error("µ94721 need settings.icql_path");
    }
    R = {
      $: {}
    };
    R.$.settings = assign({}, settings);
    /* TAINT consider to use `new`-less call convention (should be possible acc. to bsql3 docs) */
    R.$.db = new settings.connector(R.$.settings.db_path, (ref = R.$.settings.db_settings) != null ? ref : {});
    R.$.sql = IC.read_definitions(R.$.settings.icql_path);
    this._bind_definitions(R);
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._bind_definitions = function(me) {
    var check_unique, ic_entry, local_method, name, ref;
    check_unique = function(name) {
      if (me[name] != null) {
        throw new Error(`µ11292 name collision: ${rpr(name)} already defined`);
      }
    };
//.........................................................................................................
    for (name in local_methods) {
      local_method = local_methods[name];
      (function(name, local_method) {
        check_unique(name);
        local_method = local_method.bind(me.$);
        return me.$[name] = (function(...P) {
          return local_method(me, ...P);
        }).bind(me.$);
      })(name, local_method);
    }
    ref = me.$.sql;
    //.........................................................................................................
    for (name in ref) {
      ic_entry = ref[name];
      /* TAINT fix in intercourse */
      ic_entry.name = name;
      check_unique(name);
      me[name] = this._method_from_ic_entry(me, ic_entry);
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._method_from_ic_entry = function(me, ic_entry) {
    var endpoint;
    endpoint = (function() {
      switch (ic_entry.type) {
        case 'procedure':
          return me.$.execute;
        case 'query':
          return me.$.query;
        default:
          throw new Error(`µ11109 unknown icSQL type ${rpr(ic_entry.type)}`);
      }
    })();
    return (Q) => {
      var descriptor;
      descriptor = this._descriptor_from_arguments(me, ic_entry, Q);
      if (Q != null) {
        return endpoint(descriptor.text, Q);
      }
      return endpoint(descriptor.text);
    };
  };

  //-----------------------------------------------------------------------------------------------------------
  this._descriptor_from_arguments = function(me, ic_entry, Q) {
    var R, is_void_signature, kenning, ref, signature;
    [signature, kenning] = IC.get_signature_and_kenning(Q);
    is_void_signature = kenning === '()' || kenning === 'null';
    if (is_void_signature) {
      R = (ref = ic_entry['()']) != null ? ref : ic_entry['null'];
    } else {
      R = ic_entry[kenning];
    }
    if (R == null) {
      R = ic_entry['null'];
    }
    //.........................................................................................................
    if (R == null) {
      throw new Error(`µ93832 calling method with arguments ${ic_entry.name} with signature ${kenning} not implemented`);
    }
    return R;
  };

}).call(this);

//# sourceMappingURL=main.js.map
