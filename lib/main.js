// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var CND, IC, Sqlite_db, assign, badge, debug, echo, help, info, inspect, jr, limit, rpr, urge, warn, whisper, xrpr;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'ICQL/MAIN';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  // PATH                      = require 'path'
  // PD                        = require 'pipedreams'
  // { $
  //   $async
  //   select }                = PD
  ({assign, jr} = CND);

  // #...........................................................................................................
  // join_path                 = ( P... ) -> PATH.resolve PATH.join P...
  // boolean_as_int            = ( x ) -> if x then 1 else 0
  ({inspect} = require('util'));

  xrpr = function(x) {
    return inspect(x, {
      colors: true,
      breakLength: 2e308,
      maxArrayLength: 2e308,
      depth: 2e308
    });
  };

  //...........................................................................................................
  IC = require('intercourse');

  Sqlite_db = require('better-sqlite3');

  //-----------------------------------------------------------------------------------------------------------
  limit = function*(n, iterator) {
    var count, x;
    count = 0;
    for (x of iterator) {
      if (count >= n) {
        return;
      }
      count += +1;
      yield x;
    }
  };

  // #-----------------------------------------------------------------------------------------------------------
  // @get_settings = ->
  //   ### TAINT path within node_modules might differ ###
  //   ### TAINT extensions should conceivably be configured in `*.icql` file or similar ###
  //   # R.db_path   = join_path __dirname, '../../db/data.db'
  //   R                 = {}
  //   R.sqlitemk_path   = join_path __dirname, '../../../../sqlite-for-mingkwai-ime'
  //   R.db_path         = join_path __dirname, '../../src/experiments/demo-using-intercourse.db'
  //   R.icql_path       = join_path __dirname, '../../src/experiments/using-intercourse-with-sqlite.icql'
  //   return R

  //-----------------------------------------------------------------------------------------------------------
  this.bind = async function(settings) {
    var R, ref;
    if (settings.db_path == null) {
      throw new Error("µ94721 need settings.db_path");
    }
    if (settings.icql_path == null) {
      throw new Error("µ94721 need settings.icql_path");
    }
    R = {};
    R.settings = assign({}, settings);
    R.db = new Sqlite_db(R.settings.db_path, (ref = R.settings.db_settings) != null ? ref : {});
    R.sql = (await IC.read_definitions(R.settings.icql_path));
    // debug '22233', R.sql; xxx
    this._bind_definitions(R);
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._bind_definitions = function(me) {
    var check_unique, i, ic_entry, len, name, ref, ref1;
    check_unique = function(name) {
      if (me[name] != null) {
        throw new Error(`µ11292 name collision: ${rpr(name)} already defined`);
      }
    };
    ref = 'load prepare execute query'.split(/\s+/);
    //.........................................................................................................
    for (i = 0, len = ref.length; i < len; i++) {
      name = ref[i];
      check_unique(name);
      ((name) => {
        return me[name] = (...P) => {
          return this[name](me, ...P);
        };
      })(name);
    }
    ref1 = me.sql;
    //.........................................................................................................
    for (name in ref1) {
      ic_entry = ref1[name];
      /* TAINT fix in intercourse */
      ic_entry.name = name;
      check_unique(name);
      me[name] = this._method_from_ic_entry(me, ic_entry);
    }
    //.........................................................................................................
    return null;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._method_from_ic_entry = function(me, ic_entry) {
    var endpoint;
    endpoint = (function() {
      switch (ic_entry.type) {
        case 'procedure':
          return this.execute;
        case 'query':
          return this.query;
        default:
          throw new Error(`µ11109 unknown icSQL type ${rpr(ic_entry.type)}`);
      }
    }).call(this);
    return (Q) => {
      var descriptor;
      descriptor = this._descriptor_from_arguments(me, ic_entry, Q);
      if (Q != null) {
        return endpoint(me, descriptor.text, Q);
      }
      return endpoint(me, descriptor.text);
    };
  };

  //-----------------------------------------------------------------------------------------------------------
  this._descriptor_from_arguments = function(me, ic_entry, Q) {
    var R, arity, ref;
    if (Q != null) {
      if (!CND.isa_pod(Q)) {
        throw new Error("µ83476 positional arguments not supported");
      }
      arity = (Object.keys(Q)).length;
    } else {
      arity = 0;
    }
    //.........................................................................................................
    if (arity === 0) {
      R = (ref = ic_entry.arity[0]) != null ? ref : ic_entry.arity['null'];
    } else {
      R = ic_entry.arity[arity];
    }
    if (R == null) {
      R = ic_entry.arity['null'];
    }
    //.........................................................................................................
    /* TAINT should devise a way to efficiently make sure keys of Q match signature */
    // debug '27276', xrpr Q
    // debug '27276', xrpr R.signature
    //.........................................................................................................
    if (R == null) {
      throw new Error(`µ93832 calling method ${rpr(ic_entry.name)} with ${arity} arguments not implemented`);
    }
    return R;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.load = (me, path) => {
    return me.db.loadExtension(path);
  };

  this.prepare = (me, sql) => {
    return me.db.prepare(sql);
  };

  this.execute = (me, sql) => {
    return me.db.exec(sql);
  };

  this.query = (me, sql, ...P) => {
    return (this.prepare(me, sql)).iterate(...P);
  };

  //-----------------------------------------------------------------------------------------------------------
  this.demo = async function() {
    var db, ref, ref1, ref2, ref3, ref4, ref5, row, settings;
    settings = this.get_settings();
    db = (await ICQL.bind(settings));
    db.load(join_path(settings.sqlitemk_path, 'extensions/amatch.so'));
    db.load(join_path(settings.sqlitemk_path, 'extensions/csv.so'));
    // R.db.exec """select load_extension( 'fts5' );"""
    db.import_table_texnames();
    db.create_token_tables();
    db.populate_token_tables();
    // # whisper '-'.repeat 108
    // # info row for row from db.fetch_texnames()
    whisper('-'.repeat(108));
    urge('fetch_texnames');
    ref = db.fetch_texnames({
      limit: 100
    });
    for (row of ref) {
      info(xrpr(row));
    }
    // urge 'fetch_rows_of_txftsci'; info xrpr row for row from db.fetch_rows_of_txftsci { limit: 5, }
    // urge 'fetch_rows_of_txftscs'; info xrpr row for row from db.fetch_rows_of_txftscs { limit: 5, }
    urge('fetch_stats');
    ref1 = db.fetch_stats();
    for (row of ref1) {
      info(xrpr(row));
    }
    whisper('-'.repeat(108));
    urge('fetch_token_matches');
    whisper('-'.repeat(108));
    ref2 = db.fetch_token_matches({
      q: 'Iota',
      limit: 10
    });
    for (row of ref2) {
      info(xrpr(row));
    }
    whisper('-'.repeat(108));
    ref3 = db.fetch_token_matches({
      q: 'acute',
      limit: 10
    });
    for (row of ref3) {
      info(xrpr(row));
    }
    whisper('-'.repeat(108));
    ref4 = db.fetch_token_matches({
      q: 'u',
      limit: 10
    });
    for (row of ref4) {
      info(xrpr(row));
    }
    whisper('-'.repeat(108));
    ref5 = limit(3, db.fetch_token_matches({
      q: 'mathbb',
      limit: 10
    }));
    for (row of ref5) {
      info(xrpr(row));
    }
    // debug ( k for k of iterator )
    return null;
  };

  //###########################################################################################################
  if (module.parent == null) {
    this.demo();
  }

}).call(this);

//# sourceMappingURL=main.js.map
