// Generated by CoffeeScript 2.3.2
(function() {
  'use strict';
  var CND, FS, IC, assign, badge, debug, echo, help, info, inspect, jr, local_methods, rpr, urge, warn, whisper, xrpr;

  //###########################################################################################################
  CND = require('cnd');

  rpr = CND.rpr;

  badge = 'ICQL/MAIN';

  debug = CND.get_logger('debug', badge);

  warn = CND.get_logger('warn', badge);

  info = CND.get_logger('info', badge);

  urge = CND.get_logger('urge', badge);

  help = CND.get_logger('help', badge);

  whisper = CND.get_logger('whisper', badge);

  echo = CND.echo.bind(CND);

  //...........................................................................................................
  // PATH                      = require 'path'
  // PD                        = require 'pipedreams'
  // { $
  //   $async
  //   select }                = PD
  ({assign, jr} = CND);

  // #...........................................................................................................
  // join_path                 = ( P... ) -> PATH.resolve PATH.join P...
  // boolean_as_int            = ( x ) -> if x then 1 else 0
  ({inspect} = require('util'));

  xrpr = function(x) {
    return inspect(x, {
      colors: true,
      breakLength: 2e308,
      maxArrayLength: 2e308,
      depth: 2e308
    });
  };

  //...........................................................................................................
  FS = require('fs');

  IC = require('intercourse');

  //===========================================================================================================
  // LOCAL METHODS
  //-----------------------------------------------------------------------------------------------------------
  local_methods = {
    //---------------------------------------------------------------------------------------------------------
    limit: function*(me, n, iterator) {
      var count, x;
      count = 0;
      for (x of iterator) {
        if (count >= n) {
          return;
        }
        count += +1;
        yield x;
      }
    },
    //---------------------------------------------------------------------------------------------------------
    single_row: function(me, iterator) {
      var R;
      if ((R = this.first_row(iterator)) === void 0) {
        throw new Error("µ33833 expected at least one row, got none");
      }
      return R;
    },
    //---------------------------------------------------------------------------------------------------------
    all_first_values: function(me, iterator) {
      var R, key, row, value;
      R = [];
      for (row of iterator) {
        for (key in row) {
          value = row[key];
          R.push(value);
          break;
        }
      }
      return R;
    },
    //---------------------------------------------------------------------------------------------------------
    first_values: function*(me, iterator) {
      var R, key, row, value;
      R = [];
      for (row of iterator) {
        for (key in row) {
          value = row[key];
          yield value;
        }
      }
      return R;
    },
    //---------------------------------------------------------------------------------------------------------
    first_row: function(me, iterator) {
      var row;
      for (row of iterator) {
        return row;
      }
    },
    /* TAINT must ensure order of keys in row is same as order of fields in query */
    single_value: function(me, iterator) {
      var key, ref, value;
      ref = this.single_row(iterator);
      for (key in ref) {
        value = ref[key];
        return value;
      }
    },
    first_value: function(me, iterator) {
      var key, ref, value;
      ref = this.first_row(iterator);
      for (key in ref) {
        value = ref[key];
        return value;
      }
    },
    all_rows: function(me, iterator) {
      return [...iterator];
    },
    //---------------------------------------------------------------------------------------------------------
    query: function(me, sql, ...P) {
      var statement;
      statement = this.prepare(sql);
      return statement.iterate(...P);
    },
    //---------------------------------------------------------------------------------------------------------
    prepare: function(me, ...P) {
      return me.$.db.prepare(...P);
    },
    aggregate: function(me, ...P) {
      return me.$.db.aggregate(...P);
    },
    backup: function(me, ...P) {
      return me.$.db.backup(...P);
    },
    checkpoint: function(me, ...P) {
      return me.$.db.checkpoint(...P);
    },
    close: function(me, ...P) {
      return me.$.db.close(...P);
    },
    execute: function(me, ...P) {
      return me.$.db.exec(...P);
    },
    read: function(me, path) {
      return me.$.db.exec(FS.readFileSync(path, {
        encoding: 'utf-8'
      }));
    },
    function: function(me, ...P) {
      return me.$.db.function(...P);
    },
    load: function(me, ...P) {
      return me.$.db.loadExtension(...P);
    },
    pragma: function(me, ...P) {
      return me.$.db.pragma(...P);
    },
    transaction: function(me, ...P) {
      return me.$.db.transaction(...P);
    },
    //.........................................................................................................
    as_identifier: function(me, text) {
      return '"' + (text.replace(/"/g, '""')) + '"';
    },
    /* TAINT kludge: we sort by descending types so views, tables come before indexes (b/c you can't drop a
    primary key index in SQLite) */
    catalog: function(me) {
      return this.query("select * from sqlite_master order by type desc, name;");
    },
    //---------------------------------------------------------------------------------------------------------
    clear: function(me) {
      var count, i, len, name, ref, statement, type;
      count = 0;
      ref = this.all_rows(this.catalog());
      for (i = 0, len = ref.length; i < len; i++) {
        ({type, name} = ref[i]);
        statement = `drop ${type} if exists ${this.as_identifier(name)};`;
        me.$.execute(statement);
        count += +1;
      }
      return count;
    }
  };

  //===========================================================================================================

  //-----------------------------------------------------------------------------------------------------------
  this.bind = function(settings) {
    var me;
    if (settings.connector == null) {
      throw new Error("µ94721 need settings.connector");
    }
    if (settings.db_path == null) {
      throw new Error("µ94721 need settings.db_path");
    }
    if (settings.icql_path == null) {
      throw new Error("µ94721 need settings.icql_path");
    }
    me = {
      $: {}
    };
    // me.$.settings = assign {}, settings
    this.connect(me, settings.connector, settings.db_path, settings.db_settings);
    this.definitions_from_path_sync(me, settings.icql_path);
    this.bind_definitions(me);
    return me;
  };

  //-----------------------------------------------------------------------------------------------------------
  /* TAINT should check connector API compatibility */
  /* TAINT consider to use `new`-less call convention (should be possible acc. to bsql3 docs) */
  this.connect = function(me, connector, db_path, db_settings = {}) {
    (me.$ != null ? me.$ : me.$ = {}).db = new connector(db_path, db_settings);
    return me;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.definitions_from_path_sync = function(me, icql_path) {
    (me.$ != null ? me.$ : me.$ = {}).sql = IC.definitions_from_path_sync(icql_path);
    return me;
  };

  //-----------------------------------------------------------------------------------------------------------
  this.bind_definitions = function(me) {
    var check_unique, ic_entry, local_method, name, ref;
    check_unique = function(name) {
      if (me[name] != null) {
        throw new Error(`µ11292 name collision: ${rpr(name)} already defined`);
      }
    };
    if (me.$ == null) {
      me.$ = {};
    }
//.........................................................................................................
    for (name in local_methods) {
      local_method = local_methods[name];
      (function(name, local_method) {
        var method;
        check_unique(name);
        local_method = local_method.bind(me.$);
        method = function(...P) {
          var error;
          try {
            return local_method(me, ...P);
          } catch (error1) {
            error = error1;
            warn(`when trying to call method ${name} with ${xrpr(P)}`);
            warn(`an error occurred: ${error.message}`);
            throw error;
          }
        };
        return me.$[name] = method.bind(me.$);
      })(name, local_method);
    }
    ref = me.$.sql;
    //.........................................................................................................
    for (name in ref) {
      ic_entry = ref[name];
      /* TAINT fix in intercourse */
      ic_entry.name = name;
      check_unique(name);
      me[name] = this._method_from_ic_entry(me, ic_entry);
    }
    //.........................................................................................................
    return me;
  };

  //-----------------------------------------------------------------------------------------------------------
  this._method_from_ic_entry = function(me, ic_entry) {
    var endpoint;
    endpoint = (function() {
      switch (ic_entry.type) {
        case 'procedure':
          return me.$.execute;
        case 'query':
          return me.$.query;
        default:
          throw new Error(`µ11109 unknown icSQL type ${rpr(ic_entry.type)}`);
      }
    })();
    return (Q) => {
      var descriptor;
      descriptor = this._descriptor_from_arguments(me, ic_entry, Q);
      if (Q != null) {
        return endpoint(descriptor.text, Q);
      }
      return endpoint(descriptor.text);
    };
  };

  //-----------------------------------------------------------------------------------------------------------
  this._descriptor_from_arguments = function(me, ic_entry, Q) {
    var R, is_void_signature, kenning, ref, signature;
    [signature, kenning] = IC.get_signature_and_kenning(Q);
    is_void_signature = kenning === '()' || kenning === 'null';
    if (is_void_signature) {
      R = (ref = ic_entry['()']) != null ? ref : ic_entry['null'];
    } else {
      R = ic_entry[kenning];
    }
    if (R == null) {
      R = ic_entry['null'];
    }
    //.........................................................................................................
    if (R == null) {
      throw new Error(`µ93832 calling method ${rpr(ic_entry.name)} with signature ${kenning} not implemented`);
    }
    return R;
  };

}).call(this);

//# sourceMappingURL=main.js.map
